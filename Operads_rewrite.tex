%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The magmatic operad, quotients, and rewrite relations}
\label{sec:operad_Mag}
We set in this preliminary section our notations about operads. We also
provide a definition for the magmatic operad and introduce tools to
handle with some of its quotients involving rewrite systems on binary
trees.
\medbreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Nonsymmetric operads}
A \Def{nonsymmetric operad in the category of sets} (or a
\Def{nonsymmetric operad} for short) is a graded set
\begin{equation}
    \Oca = \bigsqcup_{n \geq 1} \Oca(n)
\end{equation}
together with maps
\begin{equation}
    \circ_i : \Oca(n) \times \Oca(m) \to \Oca(n + m - 1),
    \qquad 1 \leq i \leq n, 1 \leq m,
\end{equation}
called \Def{partial compositions}, and a distinguished element
$\Unit \in \Oca(1)$, the \Def{unit} of $\Oca$. This data has to satisfy,
for any $x \in \Oca(n)$, $y \in \Oca(m)$, and $z \in \Oca$, the three
relations
\begin{subequations}
\begin{equation} \label{equ:operad_axiom_1}
    (x \circ_i y) \circ_{i + j - 1} z = x \circ_i (y \circ_j z),
    \qquad
    1 \leq i \leq n, 1 \leq j \leq m,
\end{equation}
\begin{equation} \label{equ:operad_axiom_2}
    (x \circ_i y) \circ_{j + m - 1} z = (x \circ_j z) \circ_i y,
    \qquad
    1 \leq i < j \leq n,
\end{equation}
\begin{equation} \label{equ:operad_axiom_3}
    \Unit \circ_1 x = x = x \circ_i \Unit,
    \qquad 1 \leq i \leq n.
\end{equation}
\end{subequations}
Since we consider in this work only nonsymmetric operads, we shall call
these simply \Def{operads}.
\medbreak

Let us provide some elementary definitions and notations about operads.
If $x$ is an element of $\Oca$ such that $x \in \Oca(n)$ for an
$n \geq 1$, the \Def{arity} $|x|$ of $x$ is $n$. The
\Def{complete composition maps} of $\Oca$ are the map
\begin{equation}
    \circ : \Oca(n) \times
    \Oca\left(m_1\right) \times \dots \times \Oca\left(m_n\right)
    \to \Oca\left(m_1 + \dots + m_n\right)
\end{equation}
defined, for any $x \in \Oca(n)$ and $y_1, \dots, y_n \in \Oca$, by
\begin{equation} \label{equ:complete_composition}
    x \circ \left[y_1, \dots, y_n\right] :=
    \left(\cdots \left(\left(x \circ_n y_n\right)
    \circ_{n - 1} y_{n - 1}\right) \cdots\right) \circ_1 y_1.
\end{equation}
If $\Oca_1$ and $\Oca_2$ are two operads, a map
$\phi : \Oca_1 \to \Oca_2$ is an \Def{operad morphism} if it respects
the arities, sends the unit of $\Oca_1$ to the unit of $\Oca_2$, and
commutes with partial composition maps. A map $\phi : \Oca_1 \to \Oca_2$
is an \Def{operad antimorphism} if it respects the arities, sends the
unit of $\Oca_1$ to the unit of $\Oca_2$, and
\begin{math}
    \phi\left(x \circ_i y\right) = \phi(x) \circ_{|x|-i+1} \phi(y)
\end{math}
for all $x, y \in \Oca_1$ and $i \in [|x|]$. We say that $\Oca_2$ is a
\Def{suboperad} of $\Oca_1$ if $\Oca_2$ is a subset of $\Oca_1$
containing the unit of $\Oca_1$ and the partial composition maps of
$\Oca_2$ are the ones of $\Oca_1$ restricted on $\Oca_2$. For any subset
$\GeneratingSet$ of $\Oca$, the \Def{operad generated} by
$\GeneratingSet$ is the smallest suboperad $\Oca^\GeneratingSet$ of
$\Oca$ containing $\GeneratingSet$. When $\Oca = \Oca^\GeneratingSet$,
we say that $\GeneratingSet$ is a \Def{generating set} of $\Oca$. In
this case, and when additionally $\GeneratingSet$ is minimal among all
the subsets of $\Oca$ satisfying this property, $\GeneratingSet$ is a
\Def{minimal} generating set of $\Oca$. An \Def{operad congruence} is an
equivalence relation $\Congr$ on $\Oca$ such that $\Congr$ respects the
arities, and for any $x, x', y, y' \in \Oca$ such that $x \Congr x'$ and
$y \Congr y'$, $x \circ_i y$ is $\Congr$-equivalent to $x' \circ_i y'$
for any valid integer $i$. Given an operad congruence $\Congr$, the
\Def{quotient operad} $\Oca/_{\Congr}$ of $\Oca$ by $\Congr$ is the
operad of all $\Congr$-equivalence classes endowed with the partial
composition maps defined in the obvious way. In the case where all the
sets $\Oca(n)$, $n \geq 1$, are finite, the \Def{Hilbert series}
$\HilbertSeries_\Oca(t)$ of $\Oca$ is the series defined by
\begin{equation} \label{equ:hilbert_series}
    \HilbertSeries_\Oca(t) := \sum_{n \geq 1} \# \Oca(n) \; t^n.
\end{equation}
\medbreak

We have provided here definitions about operads in the category of sets.
Nevertheless, operads can be defined in the category of $\K$-vector
spaces, where $\K$ denotes in all this text a commutative field. We call
them \Def{linear operads} and we study a class of such operads in
Section~\ref{sec:Magmatic_operads}. All the above definitions extend for
linear operads, mainly by substituting Cartesian products $\times$ of
sets with tensor products $\otimes$ of spaces, maps with linear maps,
operad congruences with operad ideals, and cardinalities of sets with
space dimensions (for instance in~\eqref{equ:hilbert_series}).
If $\Oca$ is an operad in the category of sets, we denote by
$\K \Angle{\Oca}$ the corresponding linear operad defined on the
linear span of $\Oca$, where the partial composition maps of $\Oca$ are
extended by linearity on $\K \Angle{\Oca}$. Conversely, when $\Oca$ is
a linear operad admitting a basis $B$ such that its unit $\Unit$
belongs to $B$ and all partial composition maps are internal in $B$,
$\Oca = \K \Angle{B}$ and this operad can be studied as a
set-theoretic operad~$B$.
\medbreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Binary trees and magmatic operad}
A \Def{binary tree} is either the \Def{leaf} $\Leaf$ or a pair
$(\Tfr_1, \Tfr_2)$ of binary trees. We use the standard terminology
about binary trees (such as \Def{root}, \Def{internal node},
\Def{left child}, \Def{right child}, {\em etc.}) in this work. Let us
recall the main notions. The \Def{arity} $|\Tfr|$ (resp. \Def{degree}
$\Deg(\Tfr)$) of a binary tree $\Tfr$ is its number of leaves (resp.
internal nodes). A binary tree $\Tfr$ is \Def{quadratic} (resp.
\Def{cubic}) if $\Deg(\Tfr) = 2$ (resp. $\Deg(\Tfr) = 3$). We shall draw
binary trees the root to the top. For instance,
\begin{equation}
    \begin{tikzpicture}[xscale=.15,yscale=.18,Centering]
        \node(0)at(0.00,-4.50){};
        \node(2)at(2.00,-6.75){};
        \node(4)at(4.00,-6.75){};
        \node(6)at(6.00,-4.50){};
        \node(8)at(8.00,-4.50){};
        \node[NodeST](1)at(1.00,-2.25){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-4.50){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,-2.25){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(5);
        \draw[Edge](2)--(3);
        \draw[Edge](3)--(1);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(7);
        \draw[Edge](7)--(5);
        \draw[Edge](8)--(7);
        \node(r)at(5.00,2){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}
\end{equation}
is the graphical representation of the binary tree
\begin{math}
    ((\Leaf, (\Leaf, \Leaf)), (\Leaf, \Leaf)).
\end{math}
\medbreak

The \Def{magmatic operad} $\Mag$ is the graded set of all the binary
trees where $\Mag(n)$, $n \geq 1$, is the set of all the binary trees of
arity $n$. The partial composition maps of $\Mag$ are grafting of trees:
given two binary trees $\Tfr$ and $\Sfr$, $\Tfr \circ_i \Sfr$ is the
binary tree obtained by grafting the root of $\Sfr$ onto the $i$th leaf
(numbered from left to right) of $\Tfr$. For instance,
\begin{equation} \label{equ:example_composition_mag}
    \begin{tikzpicture}[xscale=.15,yscale=.18,Centering]
        \node(0)at(0.00,-4.50){};
        \node(2)at(2.00,-6.75){};
        \node(4)at(4.00,-6.75){};
        \node(6)at(6.00,-4.50){};
        \node(8)at(8.00,-4.50){};
        \node[NodeST](1)at(1.00,-2.25){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-4.50){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,-2.25){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(5);
        \draw[Edge](2)--(3);
        \draw[Edge](3)--(1);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(7);
        \draw[Edge](7)--(5);
        \draw[Edge](8)--(7);
        \node(r)at(5.00,2){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}
    \enspace \circ_4 \enspace
    \begin{tikzpicture}[xscale=.17,yscale=.18,Centering]
        \node(0)at(0.00,-4.67){};
        \node(2)at(2.00,-4.67){};
        \node(4)at(4.00,-4.67){};
        \node(6)at(6.00,-4.67){};
        \node[NodeST](1)at(1.00,-2.33){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,-2.33){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(3);
        \draw[Edge](2)--(1);
        \draw[Edge](4)--(5);
        \draw[Edge](5)--(3);
        \draw[Edge](6)--(5);
        \node(r)at(3.00,2){};
        \draw[Edge](r)--(3);
    \end{tikzpicture}
    \enspace = \enspace
    \begin{tikzpicture}[xscale=.15,yscale=.14,Centering]
        \node(0)at(0.00,-6.00){};
        \node(10)at(10.00,-12.00){};
        \node(12)at(12.00,-12.00){};
        \node(14)at(14.00,-6.00){};
        \node(2)at(2.00,-9.00){};
        \node(4)at(4.00,-9.00){};
        \node(6)at(6.00,-12.00){};
        \node(8)at(8.00,-12.00){};
        \node[NodeST](1)at(1.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](11)at(11.00,-9.00){\begin{math}\Product\end{math}};
        \node[NodeST](13)at(13.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,-9.00){\begin{math}\Product\end{math}};
        \node[NodeST](9)at(9.00,-6.00){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(5);
        \draw[Edge](10)--(11);
        \draw[Edge](11)--(9);
        \draw[Edge](12)--(11);
        \draw[Edge](13)--(5);
        \draw[Edge](14)--(13);
        \draw[Edge](2)--(3);
        \draw[Edge](3)--(1);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(7);
        \draw[Edge](7)--(9);
        \draw[Edge](8)--(7);
        \draw[Edge](9)--(13);
        \node(r)at(5.00,2.5){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}
\end{equation}
is a partial composition in $\Mag$. This leads, by definition, to the
following complete composition maps of $\Mag$. Given $\Tfr \in \Mag(n)$
and $\Sfr_1, \dots, \Sfr_n \in \Mag$,
\begin{math}
    \Tfr \circ \left[\Sfr_1, \dots, \Sfr_n\right]
\end{math}
is the binary tree obtained by grafting simultaneously the roots of all
the $\Sfr_i$ onto the $i$th leaves of $\Tfr$. The unit of $\Mag$ is the
leaf. The number of binary trees of arity $n \geq 1$ is the $n$th
Catalan number $\Catalan(n)$ and hence, the Hilbert series of $\Mag$ is
\begin{equation}
    \HilbertSeries_{\Mag}(t)
    = \sum_{n \geq 1} \Catalan(n) t^n
    = \sum_{n \geq 1} \binom{2n - 1}{n - 1} \frac{1}{n} t^n.
\end{equation}
\medbreak

The operad $\Mag$ can be seen as the free operad generated by one binary
element~$\Product$. It satisfies the following universality property.
Let
\begin{math}
    \GeneratingSet := \GeneratingSet(2) := \left\{\Product'\right\}
\end{math}
be the graded set containing exactly one element $\Product'$ of arity
$2$. For any operad $\Oca$ and any map
\begin{math}
    f : \GeneratingSet(2) \to \Oca(2),
\end{math}
there exists a unique operad morphism $\phi : \Mag \to \Oca$ such that
$f = \phi \circ \Corolla$, where $\Corolla$ is the map sending
$\Product'$ to the unique binary tree of degree $1$ (and then, arity
$2$). In other terms, the diagram
\begin{equation}
    \begin{tikzpicture}[xscale=1.3,yscale=1.1,Centering]
        \node(G)at(0,0){\begin{math}\GeneratingSet\end{math}};
        \node(O)at(2,0){\begin{math}\Oca\end{math}};
        \node(AG)at(0,-2){\begin{math}\Mag\end{math}};
        \draw[Map](G)--(O)node[midway,above]{\begin{math}f\end{math}};
        \draw[Injection](G)--(AG)node[midway,left]
            {\begin{math}\Corolla\end{math}};
        \draw[Map,dashed](AG)--(O)node[midway,right]
            {\begin{math}\phi\end{math}};
    \end{tikzpicture}
\end{equation}
commutes.
\medbreak

We now provide some useful tools about binary trees. Given a binary tree
$\Tfr$, we denote by $ \PrefixWord(\Tfr)$ the \Def{prefix word} of
$\Tfr$, that is the word on $\{\Zero, \Two\}$ obtained by a left to
right depth-first traversal of $\Tfr$ and by writing $\Zero$ (resp.
$\Two$) when a leaf (resp. an internal node) is encountered. For
instance,
\begin{equation}
    \begin{tikzpicture}[xscale=.15,yscale=.14,Centering]
        \node(0)at(0.00,-6.00){};
        \node(10)at(10.00,-12.00){};
        \node(12)at(12.00,-12.00){};
        \node(14)at(14.00,-6.00){};
        \node(2)at(2.00,-9.00){};
        \node(4)at(4.00,-9.00){};
        \node(6)at(6.00,-12.00){};
        \node(8)at(8.00,-12.00){};
        \node[NodeST](1)at(1.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](11)at(11.00,-9.00){\begin{math}\Product\end{math}};
        \node[NodeST](13)at(13.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,-9.00){\begin{math}\Product\end{math}};
        \node[NodeST](9)at(9.00,-6.00){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(5);
        \draw[Edge](10)--(11);
        \draw[Edge](11)--(9);
        \draw[Edge](12)--(11);
        \draw[Edge](13)--(5);
        \draw[Edge](14)--(13);
        \draw[Edge](2)--(3);
        \draw[Edge](3)--(1);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(7);
        \draw[Edge](7)--(9);
        \draw[Edge](8)--(7);
        \draw[Edge](9)--(13);
        \node(r)at(5.00,2.5){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}
    \enspace \xmapsto{\; \PrefixWord \;} \enspace
    \Two \Two \Zero \Two \Zero \Zero \Two \Two \Two \Zero \Zero \Two
    \Zero \Zero \Zero.
\end{equation}
The set of all the words on $\{\Zero, \Two\}$ is endowed with the
lexicographic order $\leq$ induced by $\Zero < \Two$. By extension, this
defines a total order on each set $\Mag(n)$, $n \geq 1$. Indeed, we set
$\Tfr \leq \Tfr'$ if $\Tfr$ and $\Tfr'$ have the same arity and
$\PrefixWord(\Tfr) \leq \PrefixWord(\Tfr')$. Let also the
\Def{left rank} of $\Tfr$ as the number $\LRank(\Tfr)$ of internal
nodes in the left branch beginning at the root of $\Tfr$. For instance,
\begin{equation}
    \begin{tikzpicture}[xscale=.15,yscale=.14,Centering]
        \node(0)at(0.00,-9.00){};
        \node(10)at(10.00,-9.00){};
        \node(12)at(12.00,-9.00){};
        \node(14)at(14.00,-9.00){};
        \node(2)at(2.00,-12.00){};
        \node(4)at(4.00,-12.00){};
        \node(6)at(6.00,-6.00){};
        \node(8)at(8.00,-9.00){};
        \node[NodeST](1)at(1.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](11)at(11.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](13)at(13.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-9.00){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](9)at(9.00,-6.00){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(5);
        \draw[Edge](10)--(9);
        \draw[Edge](11)--(7);
        \draw[Edge](12)--(13);
        \draw[Edge](13)--(11);
        \draw[Edge](14)--(13);
        \draw[Edge](2)--(3);
        \draw[Edge](3)--(1);
        \draw[Edge](4)--(3);
        \draw[Edge](5)--(7);
        \draw[Edge](6)--(5);
        \draw[Edge](8)--(9);
        \draw[Edge](9)--(11);
        \node(r)at(7.00,2.25){};
        \draw[Edge](r)--(7);
    \end{tikzpicture}
    \enspace \xmapsto{\; \LRank\; } \enspace 3.
\end{equation}
Equivalently, $\LRank(\Tfr)$ is the length of the prefix of
$\PrefixWord(\Tfr)$ containing only the letter $\Two$. A binary tree
$\Sfr$ is a \Def{subtree} of $\Tfr$ if it possible to stack $\Sfr$ onto
$\Tfr$ by possibly superimposing leaves of $\Sfr$ onto internal nodes of
$\Tfr$. More formally, by using the operad $\Mag$ and its composition
maps, this is equivalent to the fact that $\Tfr$ expresses as
\begin{equation}
    \Tfr = \Rfr \circ_i
    \left(\Sfr \circ \left[\Rfr_1, \dots, \Rfr_n\right]\right)
\end{equation}
where $\Rfr$ and $\Rfr_1$, \dots, $\Rfr_n$ are binary trees,
$i \in [|\Rfr|]$, and $n$ is the arity of $\Sfr$. When, on the contrary,
$\Sfr$ is not a subtree of $\Tfr$, we say that $\Tfr$ \Def{avoids}
$\Sfr$.
\medbreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rewrite systems on binary trees}
We present here notions about rewrite systems on binary trees. General
notations and notions appear in~\cite{BN98}.
\medbreak

A \Def{rewrite rule} is an ordered pair $(\Sfr, \Sfr')$ of binary trees
such that $|\Sfr| = |\Sfr'|$. A set $S$ of rewrite rules is a binary
relation on $\Mag$ and it shall be denoted by $\Rew$. We denote by
$\Sfr \Rew \Sfr'$ the fact that $(\Sfr, \Sfr') \in \Rew$. In the sequel,
to define a set of rewrite rules $\Rew$, we shall simply list all the
pairs $\Sfr \Rew \Sfr'$ contained in $\Rew$. The \Def{degree}
$\Deg(\Rew)$ of $\Rew$ is the maximal degree of the binary trees in
relation through $\Rew$. Note that $\Deg(\Rew)$ can be not defined when
$\Rew$ is infinite.
\medbreak

If $\Rew$ is a set of rewrite rules, we denote by $\RewContext$ the
\Def{rewrite relation induced} by $\Rew$. Formally we have
\begin{equation} \label{equ:rewrite_relation_induced}
    \Tfr \circ_i
    \left(\Sfr \circ \left[\Rfr_1, \dots, \Rfr_{n}\right]\right)
    \RewContext
    \Tfr \circ_i
    \left(\Sfr' \circ \left[\Rfr_1, \dots, \Rfr_{n}\right]\right),
\end{equation}
if $\Sfr \Rew \Sfr'$ where $n = |\Sfr|$, and $\Tfr$, $\Rfr_1$, \dots,
$\Rfr_n$ are binary trees. In other words, one has
$\Tfr \RewContext \Tfr'$ if it is possible to obtain $\Tfr'$ from $\Tfr$
by replacing a subtree $\Sfr$ of $\Tfr$ by $\Sfr'$ whenever
$\Sfr \Rew \Sfr'$. For instance, if $\Rew$ is the set of rewrite rules
containing the single rewrite rule
\begin{equation} \label{equ:example_rewrite_rule}
    \begin{tikzpicture}[xscale=.22,yscale=.22,Centering]
        \node(0)at(0.00,-3.50){};
        \node(2)at(2.00,-5.25){};
        \node(4)at(4.00,-5.25){};
        \node(6)at(6.00,-1.75){};
        \node[NodeST](1)at(1.00,-1.75){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-3.50){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[EdgeColorF](1)--(5);
        \draw[Edge](2)--(3);
        \draw[EdgeColorF](3)--(1);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(5);
        \node(r)at(5.00,1.31){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}
    \enspace \Rew \enspace
    \begin{tikzpicture}[xscale=.22,yscale=.22,Centering]
        \node(0)at(0.00,-1.75){};
        \node(2)at(2.00,-3.50){};
        \node(4)at(4.00,-5.25){};
        \node(6)at(6.00,-5.25){};
        \node[NodeST](1)at(1.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-1.75){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,-3.50){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](2)--(3);
        \draw[EdgeColorF](3)--(1);
        \draw[Edge](4)--(5);
        \draw[EdgeColorF](5)--(3);
        \draw[Edge](6)--(5);
        \node(r)at(1.00,1.31){};
        \draw[Edge](r)--(1);
    \end{tikzpicture}\,,
\end{equation}
one has
\begin{equation} \label{equ:example_rewrite_step}
    \begin{tikzpicture}[xscale=.19,yscale=.14,Centering]
        \node(0)at(0.00,-9.00){};
        \node(10)at(10.00,-12.00){};
        \node(12)at(12.00,-18.00){};
        \node(14)at(14.00,-18.00){};
        \node(16)at(16.00,-15.00){};
        \node(18)at(18.00,-9.00){};
        \node(2)at(2.00,-9.00){};
        \node(20)at(20.00,-9.00){};
        \node(4)at(4.00,-6.00){};
        \node(6)at(6.00,-12.00){};
        \node(8)at(8.00,-12.00){};
        \node[NodeST](1)at(1.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](11)at(11.00,-9.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](13)at(13.00,-15.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](15)at(15.00,-12.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](17)at(17.00,-3.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](19)at(19.00,-6.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,-9.00){\begin{math}\Product\end{math}};
        \node[NodeST](9)at(9.00,-6.00){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(3);
        \draw[Edge](10)--(11);
        \draw[EdgeColorF](11)--(9);
        \draw[Edge](12)--(13);
        \draw[Edge](13)--(15);
        \draw[Edge](14)--(13);
        \draw[Edge](15)--(11);
        \draw[Edge](16)--(15);
        \draw[Edge](17)--(5);
        \draw[Edge](18)--(19);
        \draw[Edge](19)--(17);
        \draw[Edge](2)--(1);
        \draw[Edge](20)--(19);
        \draw[Edge](3)--(5);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(7);
        \draw[Edge](7)--(9);
        \draw[Edge](8)--(7);
        \draw[EdgeColorF](9)--(17);
        \node(r)at(5.00,2.25){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}
    \enspace \RewContext \enspace
    \begin{tikzpicture}[xscale=.19,yscale=.14,Centering]
        \node(0)at(0.00,-9.00){};
        \node(10)at(10.00,-9.00){};
        \node(12)at(12.00,-18.00){};
        \node(14)at(14.00,-18.00){};
        \node(16)at(16.00,-15.00){};
        \node(18)at(18.00,-15.00){};
        \node(2)at(2.00,-9.00){};
        \node(20)at(20.00,-15.00){};
        \node(4)at(4.00,-6.00){};
        \node(6)at(6.00,-9.00){};
        \node(8)at(8.00,-9.00){};
        \node[NodeST](1)at(1.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](11)at(11.00,-6.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](13)at(13.00,-15.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](15)at(15.00,-12.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](17)at(17.00,-9.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](19)at(19.00,-12.00)
            {\begin{math}\Product\end{math}};
        \node[NodeST](3)at(3.00,-3.00){\begin{math}\Product\end{math}};
        \node[NodeST](5)at(5.00,0.00){\begin{math}\Product\end{math}};
        \node[NodeST](7)at(7.00,-6.00){\begin{math}\Product\end{math}};
        \node[NodeST](9)at(9.00,-3.00){\begin{math}\Product\end{math}};
        \draw[Edge](0)--(1);
        \draw[Edge](1)--(3);
        \draw[Edge](10)--(11);
        \draw[EdgeColorF](11)--(9);
        \draw[Edge](12)--(13);
        \draw[Edge](13)--(15);
        \draw[Edge](14)--(13);
        \draw[Edge](15)--(17);
        \draw[Edge](16)--(15);
        \draw[EdgeColorF](17)--(11);
        \draw[Edge](18)--(19);
        \draw[Edge](19)--(17);
        \draw[Edge](2)--(1);
        \draw[Edge](20)--(19);
        \draw[Edge](3)--(5);
        \draw[Edge](4)--(3);
        \draw[Edge](6)--(7);
        \draw[Edge](7)--(9);
        \draw[Edge](8)--(7);
        \draw[Edge](9)--(5);
        \node(r)at(5.00,2.25){};
        \draw[Edge](r)--(5);
    \end{tikzpicture}\,.
\end{equation}
The right member of~\eqref{equ:example_rewrite_step} is obtained by
replacing, in the tree of left member
of~\eqref{equ:example_rewrite_step}, a subtree equal to the left
member of~\eqref{equ:example_rewrite_rule} starting at the right child
of its root by the right member of~\eqref{equ:example_rewrite_rule}.
\medbreak

Let $\Rew$ be a set of rewrite rules and $\RewContext$ be the rewrite
relation induced by $\Rew$. Since $\RewContext$ is in particular a
binary relation on $\Mag$, the classical notations about closures apply
here: we denote by $\RewContextT$ (resp. $\RewContextRT$,
$\RewContextRST$) the transitive (resp. reflexive and transitive,
reflexive, symmetric, and transitive) closure of $\RewContext$.
\medbreak

When $\Tfr_0$, $\Tfr_1$, \dots, $\Tfr_k$ are binary trees such that
\begin{equation}
    \Tfr_0 \RewContext \Tfr_1 \RewContext \cdots \RewContext \Tfr_k,
\end{equation}
we say that $\Tfr_0$ is \Def{rewritable} by $\RewContext$ into $\Tfr_k$
in $k$ \Def{steps}. When there is no infinite chain
\begin{equation} \label{equ:infinite_chain}
    \Tfr_0 \RewContext \Tfr_1 \RewContext \Tfr_2 \RewContext \cdots
\end{equation}
we say that $\RewContext$ is terminating. To establish the termination
of a rewrite relation, we will use the following criterion.
\medbreak

\begin{Lemma}\label{lem:prefix_word_termination}
    Let $\Rew$ be a set of rewrite rules on $\Mag$. If for any
    $\Tfr, \Tfr' \in \Mag$ such that $\Tfr \Rew \Tfr'$ one has
    $\Tfr > \Tfr'$, then the rewrite relation induced by $\Rew$ is
    terminating.
\end{Lemma}
\begin{proof}
    Observe first that for any binary trees $\Tfr$ and $\Sfr$, the
    prefix word of $\Tfr \circ_i \Sfr$ is obtained by replacing the
    $i$th $\Zero$ of $\PrefixWord(\Tfr)$ by $\PrefixWord(\Sfr)$. For
    this reason, and due to the
    definition~\eqref{equ:complete_composition} of $\circ$, for any
    binary trees $\Sfr$ and $\Rfr_1, \dots, \Rfr_n$ where $n$ is the
    arity of $\Sfr$, the prefix word of
    $\Sfr \circ \left[\Rfr_1, \dots, \Rfr_n\right]$ is obtained by
    replacing from right to left each $\Zero$ of $\PrefixWord(\Sfr)$ by
    the prefix words of each $\Rfr_i$. This, together with the
    definition~\eqref{equ:rewrite_relation_induced} of the rewrite
    relation $\RewContext$ induced by $\Rew$ and the hypothesis of the
    statement of the lemma, implies that if $\Tfr$ and $\Tfr'$ are two
    binary trees such that $\Tfr \RewContext \Tfr'$,
    $\PrefixWord(\Tfr) > \PrefixWord\left(\Tfr'\right)$. This leads to
    the fact that any chain
    \begin{math}
        \Tfr_0 \Rew \Tfr_1 \Rew \Tfr_2 \Rew \cdots
    \end{math}
    is finite since
    \begin{math}
        \Tfr_0 > \Tfr_1 > \Tfr_2 > \cdots
    \end{math}
    and there is a finite number of binary trees of a fixed arity.
    Therefore, $\RewContext$ is terminating.
\end{proof}
\medbreak

A \Def{normal form} for $\RewContext$ is a binary tree $\Tfr$ such
that for all binary trees $\Tfr'$, $\Tfr \RewContextRT \Tfr'$ implies
$\Tfr' = \Tfr$. In other words, a normal form for $\RewContext$ is a
tree which is not rewritable by $\RewContext$. A normal form for
$\RewContext$ of a binary tree $\Tfr$ is a normal form $\overline{\Tfr}$
for $\RewContext$ such that $\Tfr\RewContextRT\overline{\Tfr}$. When no
confusion is possible, we simply say normal form instead of normal form
for $\RewContext$. The set of all the normal forms is denoted by
$\NormalForms_{\RewContext}$. The trees of $\NormalForms_{\RewContext}$
admit the following description, useful for enumerative prospects.
\medbreak

\begin{Lemma} \label{lem:normal_forms_avoiding}
    Let $\Rew$ be a set of rewrite rules on $\Mag$ and $\RewContext$ be
    the rewrite relation induced by $\Rew$. Then,
    $\NormalForms_{\RewContext}$ is the set of all the binary trees that
    avoid all the trees appearing as left members of~$\Rew$.
\end{Lemma}
\begin{proof}
    Assume first that $\Tfr$ is a binary tree avoiding all the trees
    appearing as left members of~$\Rew$. Then, due to the
    definition~\eqref{equ:rewrite_relation_induced} of $\RewContext$,
    $\Tfr$ is not rewritable by $\RewContext$. Hence, $\Tfr$ is a normal
    form for $\RewContext$. Conversely, assume that
    $\Tfr \in \NormalForms_{\RewContext}$. In this case, by definition
    of a normal form, $\Tfr$ is not rewritable by $\RewContext$, so that
    $\Tfr$ does not admit any occurrence of a tree appearing as a left
    member of~$\Rew$.
\end{proof}
\medbreak

When for all binary trees $\Tfr$, $\Sfr_1$, and $\Sfr_2$ such that
$\Tfr \RewContextRT \Sfr_1$ and $\Tfr \RewContextRT \Sfr_2$, there
exists a binary tree $\Tfr'$ such that $\Sfr_1 \RewContextRT \Tfr'$ and
$\Sfr_2 \RewContextRT \Tfr'$, we say that $\RewContext$ is
\Def{confluent}. Besides, a tree $\Tfr$ is a \Def{branching tree} for
$\RewContext$ if there exists two different trees $\Sfr_1$ and $\Sfr_2$
satisfying $\Tfr \RewContext \Sfr_1$ and $\Tfr \RewContext \Sfr_2$. In
this case, the pair $\{\Sfr_1, \Sfr_2\}$ is a \Def{branching pair} for
$\Tfr$. Moreover, the branching pair $\{\Sfr_1, \Sfr_2\}$ is
\Def{joinable} if there exists a binary tree $\Tfr'$ such that
$\Sfr_1 \RewContextRT \Tfr'$ and $\Sfr_2 \RewContextRT \Tfr'$. The
diamond lemma~\cite{New42} is based upon the inspection of the branching
pairs of a terminating rewrite relation $\RewContext$ in order to prove
its confluence.
\medbreak

\begin{Lemma} \label{lem:diamond_lemma}
    Let $\Rew$ be a set of rewrite rules on $\Mag$ and $\RewContext$ be
    the rewrite relation induced by $\Rew$. Then, if $\RewContext$ is
    terminating and all its branching pairs are joinable, $\RewContext$
    is convergent.
\end{Lemma}
\medbreak

When $\RewContext$ is terminating and confluent, $\RewContext$ is said
\Def{convergent}. We shall use the following result to prove that
a terminating rewrite relation is convergent.
\medbreak

\begin{Lemma} \label{lem:degree_confluence}
    Let $\Rew$ be a set of rewrite rules on $\Mag$ having a degree
    $\Deg(\Rew)$. Then, if the rewrite relation $\RewContext$ induced by
    $\Rew$ is terminating and all its branching pairs made of trees of
    degrees at most $2 \, \Deg(\Rew) - 1$ are joinable, $\RewContext$ is
    convergent.
\end{Lemma}
\begin{proof}
    The statement of the lemma is the specialization on rewrite
    relations on $\Mag$ of a more general result about rewrite relations
    on trees contained in~\cite{Gir16}.
\end{proof}
\medbreak

Let us now go back on operads. Let $\Congr$ be an operad congruence of
$\Mag$. If $\Tfr$ is a binary tree, we denote by $[\Tfr]_{\Congr}$ the
$\Congr$-equivalence class of $\Tfr$. By definition, $[\Tfr]_{\Congr}$
is an element of the quotient operad
\begin{equation} \label{equ:quotient_operad_mag}
    \Oca := \Mag/_{\Congr}.
\end{equation}
A set of rewrite rules $\Rew$ on $\Mag$ is an \Def{orientation} of
$\Congr$ if $\RewContextRST$ and $\Congr$ are equal as binary relations,
where $\RewContext$ is the rewrite relation induced by $\Rew$. Moreover,
$\Rew$ is a \Def{convergent} (resp. \Def{terminating}, \Def{confluent})
orientation of $\Congr$ if $\RewContext$ is convergent (resp.
terminating, confluent). We call \Def{presentation} of a quotient
operad $\Oca$ of the form~\eqref{equ:quotient_operad_mag} the data of
a generating set for the operad congruence $\Congr$. Observe that
any orientation of $\Congr$ is a presentation of $\Oca$, so that the
above nomenclature (\Def{convergent}, \Def{terminating}, and
\Def{confluent}) still holds for presentations. A presentation is said
to be \Def{finite} if it is a finite set.
\medbreak

When $\Rew$ is a convergent orientation of $\Congr$, the set
$\NormalForms_{\RewContext}$ of all normal forms of $\RewContext$ is
called a \Def{Poincar√©-Birkhoff-Witt basis} (or a \Def{PBW basis} for
short) of the quotient operad $\Oca$ (see~\cite{Hof10,DK10}). This forms
a one-to-one correspondence between the sets
$\NormalForms_{\RewContext}(n)$ and $\Oca(n)$, $n \geq 1$. In other
words, a PBW basis offers a way to assign with each $\Congr$-equivalence
class $[\Tfr]_{\Congr}$ a representative
\begin{math}
    \Tfr' \in [\Tfr]_{\Congr} \cap \NormalForms_{\RewContext}.
\end{math}
A \Def{combinatorial realization} of an operad $\Oca$ of the
form~\eqref{equ:quotient_operad_mag} is an operad $\Cca$ isomorphic to
$\Oca$ which admits an explicit description of its elements and an
explicit description of its partial composition maps. The knowledge of a
PBW basis $\Cca := \NormalForms_{\RewContext}$ of $\Oca$ provides a
combinatorial realization $\Cca$ of $\Oca$. Indeed, the partial
composition $\Tfr' \circ_i \Sfr'$ of two binary trees $\Tfr'$ and
$\Sfr'$ of $\Cca$ is the tree obtained by grafting the root of $\Sfr'$
onto the $i$th leaf of $\Tfr'$ and by rewriting by $\RewContext$ this
tree as much as possible in order to obtain a normal form. This process
is well-defined since, by hypothesis, $\RewContext$ is convergent.
\medbreak

When $\Rew$ is a terminating but not convergent orientation of $\Congr$,
we shall use a variant of the \Def{Buchberger semi-algorithm} for
operads~\cite[Section 3.7]{DK10} to compute a set of rewrite rules
$\Rew'$ such that, as binary relations $\Rew \subseteq \Rew'$, and
$\Rew'$ is a convergent orientation of $\Congr$. This semi-algorithm
takes as input a finite set of rewrite rules $\Rew$ and outputs the set
of rewrite rules $\Rew'$ satisfying the property stated above. Here is,
step by step, a description of its execution:
\begin{enumerate}[label={(\it\arabic*)}]
    \item Set $\Rew' := \Rew$ and let $\BranchingTrees$ be the set of
    branching trees for $\RewContext$.
    \smallbreak

    \item \label{item:loop_start_buchberger}
    If $\BranchingTrees$ is empty, the execution stops and the output
    is $\Rew'$.
    \smallbreak

    \item\label{item:choice_branching_tree} Otherwise, let $\Tfr$ be a
    branching tree for $\RewContext'$. Remove $\Tfr$ from
    $\BranchingTrees$.
    \smallbreak

    \item\label{item:choice_branching_pair} Let $\{\Sfr_1, \Sfr_2\}$ be
    a branching pair for $\Tfr$.
    \smallbreak

    \item\label{item:computed_normal_forms} Let $\bar{\Sfr_1}$ and
    $\bar{\Sfr_2}$ be normal forms of $\Sfr_1$ and $\Sfr_2$,
    respectively.
    \smallbreak

    \item \label{item:new_rewrite_rule_buchberger}
    If $\bar{\Sfr_1}$ is different from $\bar{\Sfr_2}$, add
    to $\Rew'$ the rewrite rule
    \begin{math}
        \max_\leq \left\{\bar{\Sfr_1}, \bar{\Sfr_2}\right\}
        \Rew'
        \min_\leq \left\{\bar{\Sfr_1}, \bar{\Sfr_2}\right\}.
    \end{math}
    \smallbreak

    \item Add to $\BranchingTrees$ all new branching trees of degrees at
    most $2 \Deg(\Rew') - 1$ created by the rewrite rule created in
    Step~\ref{item:new_rewrite_rule_buchberger}.
    \smallbreak

    \item Go to Step~\ref{item:loop_start_buchberger}.
\end{enumerate}
The set of rewrite rules $\Rew'$ outputted by this semi-algorithm is a
\Def{completion} of $\Rew$. By Lemma~\ref{lem:degree_confluence},
$\RewContext'$ is confluent. Notice that, for certain inputs $\Rew$,
this semi-algorithm never stops. Notice also that the computed
completion depend on the total order $\leq$ on the binary trees of a
same arity, the choices at Steps~\ref{item:choice_branching_tree}
and~\ref{item:choice_branching_pair} as well as the computed normal
forms at Step~\ref{item:computed_normal_forms}.
\medbreak
